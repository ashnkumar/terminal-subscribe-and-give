function e(e){const t=[];for(let n=0;n<e.length;n++){const a=e[n];t.push([n,a])}return t}function t(e){const t=Object.keys(e);let n=t.length;const a=new Array(n);for(;n--;)a[n]=[t[n],e[t[n]]];return a}function n(e){return"string"==typeof e?`"${e.replace(/"/g,'"')}"`:`${e}`}function a(e){return e}function r(e){return(t,n)=>e(t)?[]:n.fail()}function o(e){return t={type:()=>e.type,validateBeforeMap:e.validate,validateBeforeUnmap:e.validate,map:e.map,unmap:e.map},Object.assign(Object.assign({},t),{validateBeforeMapXml:t.validateBeforeUnmap,mapXml:t.map,unmapXml:t.unmap});var t}function l(e){return"number"==typeof e||"string"==typeof e&&!isNaN(e)}function i(e){return"number"==typeof e?e:+e}function p(e){return"bigint"==typeof e?e:BigInt(e)}function m(e,t){const n=new Set(t),a={};for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&!n.has(t)&&(a[t]=e[t]);return a}function u(e){return-1!==e.indexOf(" ")?n(e):e}function c(e,t){const n=v(y(e,t.type())),a=t.validateBeforeMap(e,n);return 0===a.length?{errors:!1,result:t.map(e,n)}:{errors:a}}function f(e,t){const n=v(y(e,t.type())),a=t.validateBeforeUnmap(e,n);return 0===a.length?{errors:!1,result:t.unmap(e,n)}:{errors:a}}function s(e,t){const n=v(y(e,t.type())),a=t.validateBeforeMapXml(e,n);return 0===a.length?{errors:!1,result:t.mapXml(e,n)}:{errors:a}}function d(e,t){const n=v(y(e,t.type())),a=t.validateBeforeUnmap(e,n);return 0===a.length?{errors:!1,result:t.unmapXml(e,n)}:{errors:a}}function y(e,t){return{value:e,type:t,branch:[e],path:[]}}function v(e){const t=(t,n,a)=>v({value:n,type:a.type(),branch:[...e.branch,n],path:[...e.path,t]}),n=(e,n,a)=>e.map((e=>a(e,t(e[0],e[1],n))));return Object.assign(Object.assign({},e),{createChild:t,flatmapChildren:(...e)=>function(e){const t=[];for(const n of e)for(const e of n)t.push(e);return t}(n(...e)),mapChildren:n,fail:t=>[Object.assign(Object.assign({},e),{message:b(e,t)})]})}function b(e,t){const n=JSON.stringify(e.value,((e,t)=>"bigint"==typeof t?t.toString():t));if(t=(null!=t?t:`Expected value to be of type '${e.type}' but found '${typeof e.value}'.`)+"\n"+`\nGiven value: ${n}`+`\nType: '${typeof e.value}'`+`\nExpected type: '${e.type}'`,e.path.length>0){t+=`\nPath: ${e.path.map((e=>u(e.toString()))).join(" â€º ")}`}return t}function h(t,n){let a;return a={type:()=>`Array<${t.type()}>`,validateBeforeMap:(n,a)=>Array.isArray(n)?a.flatmapChildren(e(n),t,((e,n)=>t.validateBeforeMap(e[1],n))):a.fail(),validateBeforeUnmap:(n,a)=>Array.isArray(n)?a.flatmapChildren(e(n),t,((e,n)=>t.validateBeforeUnmap(e[1],n))):a.fail(),map:(n,a)=>a.mapChildren(e(n),t,((e,n)=>t.map(e[1],n))),unmap:(n,a)=>a.mapChildren(e(n),t,((e,n)=>t.unmap(e[1],n))),mapXml:(a,r)=>{let o=a;return(null==n?void 0:n.xmlItemName)&&(o=a[n.xmlItemName],r=r.createChild(n.xmlItemName,o,t)),r.mapChildren(e(o),t,((e,n)=>t.mapXml(e[1],n)))},unmapXml:(a,r)=>{const o=r.mapChildren(e(a),t,((e,n)=>t.unmapXml(e[1],n)));return(null==n?void 0:n.xmlItemName)?{[n.xmlItemName]:o}:o},validateBeforeMapXml:(a,r)=>{let o=a;if(null==n?void 0:n.xmlItemName){const e=`Expected array to be wrapped with XML element ${n.xmlItemName}.`;if("object"!=typeof a||null===a||!(n.xmlItemName in a))return r.fail(e);o=a[n.xmlItemName],r=r.createChild(n.xmlItemName,o,t)}return Array.isArray(o)?r.flatmapChildren(e(o),t,((e,n)=>t.validateBeforeMapXml(e[1],n))):r.fail()}},a}function j(e){return"bigint"==typeof e||"number"==typeof e||"string"==typeof e&&/^-?\d+$/.test(e)}function O(){return o({type:"bigint",validate:r(j),map:p})}function X(e){return"boolean"==typeof e||"string"==typeof e&&("true"===e||"false"===e)}function B(){return o({type:"boolean",validate:r(X),map:e=>"boolean"==typeof e?e:"true"===e})}function g(e,t){return{type:()=>`Defaults<${e.type()},${n(t)}>`,validateBeforeMap:(n,a)=>M(n,t)?[]:e.validateBeforeMap(n,a),validateBeforeUnmap:(n,a)=>M(n,t)?[]:e.validateBeforeUnmap(n,a),map:(n,a)=>M(n,t)?t:e.map(n,a),unmap:(n,a)=>M(n,t)?t:e.unmap(n,a),validateBeforeMapXml:(n,a)=>M(n,t)?[]:e.validateBeforeMapXml(n,a),mapXml:(n,a)=>M(n,t)?t:e.mapXml(n,a),unmapXml:(n,a)=>M(n,t)?t:e.unmapXml(n,a)}}function M(e,t){return null==e||e===t}function $(e){const n=(n,a,r)=>{if("object"!=typeof a||null===a)return r.fail();const o=a;return r.flatmapChildren(t(o),e,((t,a)=>e[n](t[1],a)))};return{type:()=>`Record<string,${e.type()}>`,validateBeforeMap:(...e)=>n("validateBeforeMap",...e),validateBeforeUnmap:(...e)=>n("validateBeforeUnmap",...e),map:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.map(o,n.createChild(r,o,e))}return a},unmap:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.unmap(o,n.createChild(r,o,e))}return a},validateBeforeMapXml:(...e)=>n("validateBeforeMapXml",...e),mapXml:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.mapXml(o,n.createChild(r,o,e))}return a},unmapXml:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.unmapXml(o,n.createChild(r,o,e))}return a}}}function x(e){const n=$(e),a=Object.assign({},n);return a.unmapXml=(e,a)=>({entry:t(n.unmapXml(e,a)).map((([e,t])=>({$:{key:e},_:t})))}),a.mapXml=(e,t)=>{if(!("entry"in e))return{};let{entry:a}=e;Array.isArray(a)||(a=[a]);const r={};for(const e of a)r[e.$.key]=e._;return n.mapXml(r,t)},a.validateBeforeMapXml=(e,t)=>{if("object"!=typeof e||null===e)return t.fail();if(!("entry"in e))return[];let a=e.entry;Array.isArray(a)||(a=[a]);const r={};for(const e of a){if("object"!=typeof e||null===e)return t.fail('Expected "entry" to be an XML element.');if(!("$"in e)||!("key"in e.$))return t.fail('Expected "entry" element to have an attribute named "key".');const n=e;r[n.$.key]=n._}return n.validateBeforeMapXml(r,t)},a}function S(e,n,a,r,o){const l=(e,t,n=!1)=>{if("object"==typeof e&&null!==e&&(n&&function(e,t){return"$"in e&&"object"==typeof e.$&&t in e.$}(e,t)||!n&&t in e)){const r=n?e.$[t]:e[t];if("string"==typeof r&&r in a)return a[r]}return a[r]};return{type:()=>`DiscriminatedUnion<${n},[${t(a).map((([e,t])=>t.type)).join(",")}]>`,map:(e,t)=>l(e,n).map(e,t),unmap:(t,n)=>l(t,e).unmap(t,n),validateBeforeMap:(e,t)=>l(e,n).validateBeforeMap(e,t),validateBeforeUnmap:(t,n)=>l(t,e).validateBeforeUnmap(t,n),mapXml:(e,t)=>{var a;return l(e,null!==(a=null==o?void 0:o.xmlName)&&void 0!==a?a:n,null==o?void 0:o.isAttr).mapXml(e,t)},unmapXml:(t,n)=>l(t,e).unmapXml(t,n),validateBeforeMapXml:(e,t)=>{var a;return l(e,null!==(a=null==o?void 0:o.xmlName)&&void 0!==a?a:n,null==o?void 0:o.isAttr).validateBeforeMapXml(e,t)}}}function w(e){const t=function(e){let t,n=!1;return function(...a){return n||(n=!0,t=e.apply(this,a)),t}}(e);return{type:()=>`Lazy<${t().type()}>`,map:(...e)=>t().map(...e),unmap:(...e)=>t().unmap(...e),validateBeforeMap:(...e)=>t().validateBeforeMap(...e),validateBeforeUnmap:(...e)=>t().validateBeforeUnmap(...e),mapXml:(...e)=>t().mapXml(...e),unmapXml:(...e)=>t().unmapXml(...e),validateBeforeMapXml:(...e)=>t().validateBeforeMapXml(...e)}}function N(e){return o({type:`Literal<${n(e)}>`,validate:r((t=>e===t)),map:()=>e})}function P(e){return{type:()=>`Nullable<${e.type()}>`,validateBeforeMap:(t,n)=>null===t?[]:e.validateBeforeMap(t,n),validateBeforeUnmap:(t,n)=>null===t?[]:e.validateBeforeUnmap(t,n),map:(t,n)=>null===t?null:e.map(t,n),unmap:(t,n)=>null===t?null:e.unmap(t,n),validateBeforeMapXml:(t,n)=>null===t?[]:e.validateBeforeMapXml(t,n),mapXml:(t,n)=>null===t?null:e.mapXml(t,n),unmapXml:(t,n)=>null===t?null:e.unmapXml(t,n)}}function A(){return o({type:"number",validate:r(l),map:i})}function U(e){const t=r(function(e){const t=Object.values(e);return e=>l(e)&&t.includes(i(e))}(e));return o({type:`Enum<${Object.values(e).filter((e=>"number"==typeof e)).join(",")}>`,map:i,validate:t})}function C(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n}function T(e){const t=D(e,!1,!1);return t.type=()=>`StrictObject<{${Object.keys(e).map(u).join(",")}}>`,t}function k(e){return D(e,!0,!0)}function I(e){const t=D(e,!0,!1);return t.type=()=>`Object<{${Object.keys(e).map(u).join(",")}}>`,t}function E(e,t){return T(Object.assign(Object.assign({},e.objectSchema),t))}function L(e,t){return k(Object.assign(Object.assign({},e.objectSchema),t))}function _(e,t){return I(Object.assign(Object.assign({},e.objectSchema),t))}function D(e,t,n){const a=Object.keys(e),r=H(e),o=function(e){var t,n;const a={},r={};for(const o in e)if(Object.prototype.hasOwnProperty.call(e,o)){const[l,,i]=e[o];!0===(null==i?void 0:i.isAttr)?r[null!==(t=i.xmlName)&&void 0!==t?t:l]=o:a[null!==(n=null==i?void 0:i.xmlName)&&void 0!==n?n:l]=o}return{elementsToProps:a,attributesToProps:r}}(e),l=function(e){var t;const n={},a={};for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const o=e[r],[l,i,p]=o;((null==p?void 0:p.isAttr)?a:n)[r]=[null!==(t=null==p?void 0:p.xmlName)&&void 0!==t?t:l,i,p]}return{elementsSchema:n,attributesSchema:a}}(e),i=function(e){return{attributesSchema:H(e.attributesSchema),elementsSchema:H(e.elementsSchema)}}(l);return{type:()=>`Object<{${a.map(u).join(",")},...}>`,validateBeforeMap:q(e,"validateBeforeMap",t),validateBeforeUnmap:q(r,"validateBeforeUnmap",t),map:F(e,"map",n),unmap:F(r,"unmap",n),validateBeforeMapXml:z(e,o,t),mapXml:G(l,n),unmapXml:J(i,n),objectSchema:e}}function z(e,t,n){const{elementsToProps:a,attributesToProps:r}=t;return(t,o)=>{if("object"!=typeof t||null===t)return o.fail();const l=t,{$:i}=l,p=C(l,["$"]),m=null!=i?i:{};return[...R({validationMethod:"validateBeforeMapXml",propTypeName:"child elements",propTypePrefix:"element",valueTypeName:"element",propMapping:a,objectSchema:e,valueObject:p,ctxt:o,allowAdditionalProperties:n}),...R({validationMethod:"validateBeforeMapXml",propTypeName:"attributes",propTypePrefix:"@",valueTypeName:"element",propMapping:r,objectSchema:e,valueObject:m,ctxt:o,allowAdditionalProperties:n})]}}function G(e,n){const{elementsSchema:a,attributesSchema:r}=e,o=F(a,"mapXml",n),l=F(r,"mapXml",!1),i=t(r).map((([e,[t]])=>t));return(e,t)=>{const a=e,{$:r}=a,p=C(a,["$"]),u=null!=r?r:{},c=Object.assign(Object.assign({},l(u,t)),o(p,t));if(n){const e=m(u,i);Object.keys(e).length>0&&(c.$=e)}return c}}function J(e,n){const{elementsSchema:a,attributesSchema:r}=e,o=F(a,"unmapXml",n),l=F(r,"unmapXml",!1),i=t(r).map((([e,[t]])=>t));return(e,t)=>{const a=e,{$:r}=a,p=C(a,["$"]),u="object"==typeof r&&null!==r&&n?r:{};return Object.assign(Object.assign({},o(m(p,i),t)),{$:Object.assign(Object.assign({},u),l(e,t))})}}function R({validationMethod:e,propTypeName:t,propTypePrefix:a,valueTypeName:r,propMapping:o,objectSchema:l,valueObject:i,ctxt:p,allowAdditionalProperties:m}){const u=[],c=new Set,f=new Set(Object.keys(i));for(const t in o)if(Object.prototype.hasOwnProperty.call(o,t)){const n=l[o[t]][1];f.delete(t),t in i?u.push(...n[e](i[t],p.createChild(a+t,i[t],n))):0!==n.type().indexOf("Optional<")&&c.add(t)}const s=Array.from(f);s.length>0&&!m&&u.push(...p.fail(`Some unknown ${t} were found in the ${r}: ${s.map(n).join(", ")}.`));const d=Array.from(c);return d.length>0&&u.push(...p.fail(`Some ${t} are missing in the ${r}: ${d.map(n).join(", ")}.`)),u}function q(e,t,n){const a=function(e){const t={};for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){t[e[n][0]]=n}return t}(e);return(r,o)=>"object"!=typeof r||null===r?o.fail():R({validationMethod:t,propTypeName:"properties",propTypePrefix:"",valueTypeName:"object",propMapping:a,objectSchema:e,valueObject:r,ctxt:o,allowAdditionalProperties:n})}function F(e,t,n){return(a,r)=>{const o={},l=a,i=new Set(Object.keys(l));for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){const a=e[n],p=a[0],m=l[p];i.delete(p),0===a[1].type().indexOf("Optional<")&&void 0===m||(o[n]=a[1][t](m,r.createChild(p,m,a[1])))}return n&&i.forEach((e=>{o[e]=l[e]})),o}}function H(e){const t={};for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){const a=e[n];t[a[0]]=[n,a[1],a[2]]}return t}function K(e){return{type:()=>`Optional<${e.type()}>`,validateBeforeMap:(t,n)=>void 0===t?[]:e.validateBeforeMap(t,n),validateBeforeUnmap:(t,n)=>void 0===t?[]:e.validateBeforeUnmap(t,n),map:(t,n)=>void 0===t?void 0:e.map(t,n),unmap:(t,n)=>void 0===t?void 0:e.unmap(t,n),validateBeforeMapXml:(t,n)=>void 0===t?[]:e.validateBeforeMapXml(t,n),mapXml:(t,n)=>void 0===t?void 0:e.mapXml(t,n),unmapXml:(t,n)=>void 0===t?void 0:e.unmapXml(t,n)}}function Q(e){return"string"==typeof e}function V(){return o({type:"string",validate:r(Q),map:a})}function W(e){const t=r(function(e){const t=Object.values(e);return e=>"string"==typeof e&&t.includes(e)}(e));return o({type:`Enum<${Object.values(e).map(n).join(",")}>`,map:a,validate:t})}function Y(){return o({type:"unknown",validate:()=>[],map:a})}export{h as array,O as bigint,B as boolean,g as defaults,$ as dict,x as dictWithXmlEntries,S as discriminatedObject,k as expandoObject,L as extendExpandoObject,_ as extendObject,E as extendStrictObject,w as lazy,N as literal,P as nullable,A as number,U as numberEnum,I as object,K as optional,T as strictObject,V as string,W as stringEnum,Y as unknown,c as validateAndMap,s as validateAndMapXml,f as validateAndUnmap,d as validateAndUnmapXml};
